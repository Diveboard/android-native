package com.diveboard.dataaccess.datamodel;

import com.diveboard.model.SafetyStop;
import com.diveboard.model.Tank;
import com.diveboard.util.Utils;
import com.google.gson.Gson;
import com.google.gson.annotations.SerializedName;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

import static com.diveboard.mobile.ApplicationController.getGson;

public class Dive {
    private static SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
    @SerializedName("id")
    public Integer id;
    //shakenId is used internally in the mobile application as an dive id because real dive id is assigned only after synchronization
    //shaken_id generated by mobile app is ignored (hopefully) by backend, so backend will assign its own
    @SerializedName("shaken_id")
    public String shakenId;
    @SerializedName("time_in")
    public String timeIn;
    @SerializedName("duration")
    public Integer durationMin;
    @SerializedName("maxdepth")
    public Double maxDepth;
    @SerializedName("user_id")
    public Integer userId;
    @SerializedName("spot_id")
    public Integer spotId;
    @SerializedName("temp_surface")
    public Double airTemp;
    @SerializedName("temp_bottom")
    public Double waterTemp;
    @SerializedName("privacy")
    public Integer privacy;
    @SerializedName("weights")
    public Double weights;
    @SerializedName("safetystops")
    public String safetystops;
    //    @SerializedName("safetystops_unit_value")
//    public String safetystopsUnitValue;
    @SerializedName("divetype")
    public List<String> divetype = new ArrayList<>();
    @SerializedName("favorite")
    public Boolean favorite;
    @SerializedName("visibility")
    public String visibility;
    @SerializedName("trip_name")
    public String tripName;
    @SerializedName("water")
    public String water;
    @SerializedName("altitude")
    public Double altitude;
    @SerializedName("fullpermalink")
    public String fullpermalink;
    @SerializedName("permalink")
    public String permalink;
    @SerializedName("complete")
    public Boolean complete;
    @SerializedName("thumbnail_image_url")
    public String thumbnailImageUrl;
    @SerializedName("thumbnail_profile_url")
    public String thumbnailProfileUrl;
    @SerializedName("guide")
    public String guide;
    @SerializedName("notes")
    public String notes;
    @SerializedName("public_notes")
    public String publicNotes;
    @SerializedName("current")
    public String current;
    //    @SerializedName("date")
//    public String date;
//    @SerializedName("time")
//    public String time;
    @SerializedName("tanks")
    public List<Tank> tanks = new ArrayList();
    @SerializedName("updated_at")
    public String updatedAt;
    @SerializedName("featured_picture")
    public Picture featuredPicture;
    @SerializedName("number")
    public Integer diveNumber;
    @SerializedName("spot")
    public Spot spot;
    @SerializedName("buddies")
    public List<Buddy> buddies = new ArrayList();
    @SerializedName("pictures")
    public List<Picture> pictures = new ArrayList();
    @SerializedName("shop_id")
    public Integer diveCenterId;
    @SerializedName("shop")
    public Shop diveCenter;

    public Calendar getTimeIn() {
        try {
            Calendar calendar = Calendar.getInstance();
            calendar.setTime(dateFormat.parse(timeIn));
            //remove seconds fraction so it will not impact ordering in divelog
            calendar.set(Calendar.SECOND, 0);
            calendar.set(Calendar.MILLISECOND, 0);
            return calendar;
        } catch (ParseException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void setTimeIn(Calendar value) {
        timeIn = dateFormat.format(value.getTime());
    }

    public Boolean isFreshWater() {
        if (water == null) {
            return null;
        }
        if ("fresh".equals(water)) {
            return true;
        }
        return false;
    }

    public List<SafetyStop> getSafetyStops() {
        if (safetystops == null) {
            return new ArrayList<>();
        }
        List<SafetyStop> result = new ArrayList<>();
        Gson gson = getGson();
        try {
            String[][] res = gson.fromJson(safetystops, String[][].class);
            for (String[] ss : res) {
                result.add(new SafetyStop(Integer.parseInt(ss[0]), Integer.parseInt(ss[1])));
            }
        } catch (Exception e) {
            Utils.logError(Dive.class, "Cannot deserialize safety stops", e);
            return new ArrayList<>();
        }
        return result;
    }

    public void setSafetyStops(List<SafetyStop> safetyStops) {
        if (safetyStops == null || safetyStops.isEmpty()) {
            this.safetystops = "[]";
            return;
        }
        String[][] temp = new String[safetyStops.size()][2];
        for (int i = 0; i < safetyStops.size(); i++) {
            SafetyStop ss = safetyStops.get(i);
            temp[i][0] = ss.depthInMeters.toString();
            temp[i][1] = ss.durationInMinutes.toString();
        }
        this.safetystops = getGson().toJson(temp);
    }

    public void setFreshWater(Boolean isFreshWater) {
        if (isFreshWater == null) {
            water = null;
            return;
        }
        water = isFreshWater ? "fresh" : "salt";
    }

    public boolean existsOnline() {
        return id != null;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Dive dive = (Dive) o;
        return Utils.equals(id, dive.id) &&
                Utils.equals(shakenId, dive.shakenId) &&
                Utils.equals(getTimeIn().getTimeInMillis(), dive.getTimeIn().getTimeInMillis()) &&
                Utils.equals(durationMin, dive.durationMin) &&
                Utils.equals(maxDepth, dive.maxDepth) &&
                Utils.equals(userId, dive.userId) &&
                Utils.equals(airTemp, dive.airTemp) &&
                Utils.equals(waterTemp, dive.waterTemp) &&
//                Utils.equals(privacy, dive.privacy) &&
                Utils.equals(weights, dive.weights) &&
//                Utils.equals(safetystops, dive.safetystops) &&
//                Utils.equals(divetype, dive.divetype) &&
//                Utils.equals(favorite, dive.favorite) &&
                Utils.equals(visibility, dive.visibility) &&
                Utils.equals(tripName, dive.tripName) &&
                Utils.equals(water, dive.water) &&
                Utils.equals(altitude, dive.altitude) &&
//                Utils.equals(fullpermalink, dive.fullpermalink) &&
//                Utils.equals(permalink, dive.permalink) &&
//                Utils.equals(complete, dive.complete) &&
//                Utils.equals(thumbnailImageUrl, dive.thumbnailImageUrl) &&
//                Utils.equals(thumbnailProfileUrl, dive.thumbnailProfileUrl) &&
                Utils.equals(guide, dive.guide) &&
                Utils.equals(notes, dive.notes) &&
//                Utils.equals(publicNotes, dive.publicNotes) &&
                Utils.equals(current, dive.current) &&
//                Utils.equals(tanks, dive.tanks) &&
//                Utils.equals(updatedAt, dive.updatedAt) &&
//                Utils.equals(featuredPicture, dive.featuredPicture) &&
                Utils.equals(diveNumber, dive.diveNumber) &&
//                Utils.equals(spot, dive.spot) &&
//                Utils.equals(buddies, dive.buddies) &&
//                Utils.equals(diveCenter, dive.diveCenter) &&
//                Utils.equals(pictures, dive.pictures) &&
                Utils.equals(diveCenterId, dive.diveCenterId);
    }
}
